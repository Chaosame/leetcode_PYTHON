from typing import List

'''
    前言，这道题非常巧妙的利用了2进制数的位运算 2020-09-20 00:59
    启示，涉及2进制数的题需要第一时间写出它的二进制表示，把位运算当作主要的运算手法，观察它的左移右移的结果与其他项的对应情况
'''


class Solution:
    def countBits(self, num: int) -> List[int]:
        #   这题思路在于从最低位开始有多少个连续的1以及数字的2进制位数
        #   1、假设有2个连续1 位数为4 那么只能是1011（因为最高位不能为0，所以至少有4位）
        #   2、假设有2个连续1 位数为2 那么是11
        #   对于1.有它的下一个自然数会链式消除最低位开始的连续1 位数不变 变成1100
        #   对于2.它链式消除后需要在最前面补上1
        #   题目的时间复杂度和空间复杂度均为O(n) 对于我的原始思路这样一定是超标的
        #   关键的思路在于 我们要从2进制的表示上找到递推的关系
        #   那么自然会想到2进制的运算中最常见的左移右移(最低位)的位运算 它在10进制中会对应除以2和乘以2
        #   2（10）=10（2） 1（10）=1（2) 我们可以把2看成是由1右移得到的，这样可以发现2除了最低位其余和
        #   1是完全相同的，这样我们可以写出递推公式
        #   f(n)=f(n/2)+(n mod 2)

        # dp = [0]  # 动态规划数组dp[i]记录i有几个1
        # if num == 0:
        #     return dp
        # elif num == 1:
        #     dp.append(1)
        #     return dp
        # else:
        #     dp.append(1)
        # # for i in range(2, num + 1):
        # #     dp.append(0)
        # dp = [0] * (num+1)
        # for i in range(2, num + 1):
        #     dp[i] = dp[i // 2] + (i % 2)
        # return dp

        #   优化代码 使用 dp = [0]*(num+1)快速初始化数组
        if num == 0:
            return [0]
        dp = [0] * (num + 1)  # 动态规划数组dp[i]记录i有几个1
        if num >= 1:
            dp[1] = 1
        for i in range(2, num + 1):  # num = 1 的情况和这里完美合并了，少写一句
            dp[i] = dp[i // 2] + (i % 2)
        return dp
